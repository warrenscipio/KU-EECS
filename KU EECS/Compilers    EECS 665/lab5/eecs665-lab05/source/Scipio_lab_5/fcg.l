%{
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fcg.yacc.h>

#ifndef NDEBUG
#    define DEBUGF(...) DEBUGF(__VA_ARGS__)
#else
#    define DEBUGF(...)
#endif
%}

%option       noyywrap nounput yylineno
%x            COMMENT

whitesp       [ \t\n\r]
nonwhitesp    [^ \t\n\r]
ident         [a-zA-Z][a-zA-Z0-9_]*
digit         [0-9]
hexdigit      [0-9a-fA-F]
octdigit      [0-7]
charval       "'"(\\)?."'"

%%

%{
 /**************************************************************************
  *keywords 
  *************************************************************************/
%}


"union"     { DEBUGF("UNION\n");    return UNION; }
"register"  { DEBUGF("REGISTER\n"); return REGISTER; }
"sizeof"    { DEBUGF("SIZEOF\n");   return SIZEOF; }
"const"     { DEBUGF("CONST\n");    return CONST; }
"static"    { DEBUGF("STATIC\n");   return STATIC; }
"unsigned"  { DEBUGF("UNSIGNED\n"); return UNSIGNED; }
"typedef"   { DEBUGF("TYPEDEF\n");  return TYPEDEF; }
"struct"    { DEBUGF("STRUCT\n");   return STRUCT; }
"extern"    { DEBUGF("EXTERN\n");   return EXTERN; }
"auto"      { DEBUGF("AUTO\n");     return AUTO; }



%{
 /**************************************************************************
  *Statements
  *************************************************************************/
%}


"continue"  { DEBUGF("CONTINUE\n"); return CONTINUE; }
"break"     { DEBUGF("BREAK\n");    return BREAK; }
"goto"      { DEBUGF("GOTO\n");     return GOTO; }
"return"    { DEBUGF("RETURN\n");   return RETURN; }
"do"        { DEBUGF("DO\n");       return DO; }
"while"     { DEBUGF("WHILE\n");    return WHILE; }
"default"   { DEBUGF("DEFAULT\n");  return DEFAULT; }
"if"        { DEBUGF("IF\n");       return IF; }
"else"      { DEBUGF("ELSE\n");     return ELSE; }
"for"       { DEBUGF("FOR\n");      return FOR; }
"switch"    { DEBUGF("SWITCH\n");   return SWITCH; }
"case"      { DEBUGF("CASE\n");     return CASE; }


%{

 /**************************************************************************
  * Scan miscellaneous C punctuation. 
  *************************************************************************/
%}

"("         { DEBUGF( "(\n" ); return '('; }
")"         { DEBUGF( ")\n" ); return ')'; }
"{"         { DEBUGF( "{\n" ); return '{'; }
"}"         { DEBUGF( "}\n" ); return '}'; }
"["         { DEBUGF( "[\n" ); return '['; }
"]"         { DEBUGF( "]\n" ); return ']'; }
","         { DEBUGF( ",\n" ); return ','; }
";"         { DEBUGF( ";\n" ); return ';'; }

%{ 

 /**************************************************************************
  *binary operators. 
  *************************************************************************/
%}

"="   { DEBUGF("SET\n");      return SET; }
"=="  { DEBUGF("EQ\n");       return EQ; }
"!="  { DEBUGF("NE\n");       return NE; }
"<"   { DEBUGF("LT\n");       return LT; }
">"   { DEBUGF("GT\n");       return GT; }
"<="  { DEBUGF("LE\n");       return LE; }
">="  { DEBUGF("GE\n");       return GE; }

"+"   { DEBUGF("ADD\n");      return ADD; }
"-"   { DEBUGF("SUB\n");      return SUB; }
"*"   { DEBUGF("MUL\n");      return MUL; }
"/"   { DEBUGF("DIV\n");      return DIV; }
"%"   { DEBUGF("MOD\n");      return MOD; }

"<<"  { DEBUGF("LSH\n");      return LSH; }
">>"  { DEBUGF("RSH\n");      return RSH; }

"&"   { DEBUGF("BITAND\n");   return BITAND; }
"|"   { DEBUGF("BITOR\n");    return BITOR; }
"^"   { DEBUGF("BITXOR\n");   return BITXOR; }

"||"  { DEBUGF("OR\n");       return OR; }
"&&"  { DEBUGF("AND\n");      return AND; }



%{ 

 /**************************************************************************
  *type. 
  *************************************************************************/
%}

"void"         { DEBUGF( "VOID\n" ); return VOID; }
"char"         { DEBUGF( "CHAR\n" ); return CHAR; }
"short"        { DEBUGF( "SHORT\n" ); return SHORT; }
"int"          { DEBUGF( "INT\n" ); return INT; }
"long"         { DEBUGF( "LONG\n" ); return LONG; }
"float"        { DEBUGF( "FLOAT\n" ); return FLOAT; }
"double"       { DEBUGF( "DOUBLE\n" ); return DOUBLE; }

%{ 
 /**************************************************************************
  * Scan C identifiers.
  *************************************************************************/
%}

{ident}         { DEBUGF( "ID\n" ); yylval.id = strdup(yytext); return ID; }
{charval}       { DEBUGF( "CHARVAL\n" ); return CHARVAL; }
"\""[^<]*"\""   { DEBUGF( "STRVAL\n" ); return STRVAL; }

%{ 
 /**************************************************************************
  * Scan C literal values including strings, character literals, integer
  * literals, and floating point literals.
  *************************************************************************/
%}

"0x"{hexdigit}+    { DEBUGF( "INTVAL\n" ); return INTVAL; }
"0"{octdigit}*     { DEBUGF( "INTVAL\n" ); return INTVAL; }
[1-9]{digit}*      { DEBUGF( "INTVAL\n" ); return INTVAL; }
[0-9]+"."[0-9]+"f" { DEBUGF( "FLTVAL\n" ); return FLTVAL; }
[0-9]+"."[0-9]+    { DEBUGF( "DBLVAL\n" ); return DBLVAL; }

%{
 /**************************************************************************
  * Scan a multi-line C comment using left context or a C single line
  * comment to the end of the line.
  *************************************************************************/
%}

"//".*                      { /* ignored */ }

"/*"                        { BEGIN COMMENT; }
<COMMENT>"*/"               { BEGIN 0; }
<COMMENT>([\n](\r)?)|.      { /* ignored */ } 

%{
 /**************************************************************************
  * Scan white space in-between tokens and ignore it.
  *************************************************************************/
%}

{whitesp}+ { /* ignored */  }

%{
 /**************************************************************************
  * Anything else that matches is unexpected so print an error.
  *************************************************************************/
%}

. {
    fprintf( stderr, "Unexpected input at line %d: '%s'\n", yylineno, yytext );
    exit( 1 );
}

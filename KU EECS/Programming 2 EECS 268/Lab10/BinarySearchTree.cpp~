#include <cassert>
#include <sstream>
  
template<typename KeyType, typename ItemType>
BinarySearchTree<KeyType, ItemType>::BinarySearchTree() : rootPtr(NULL)
{
	nodeCount = 0;
}  // end default constructor

template<typename KeyType, typename ItemType>
BinarySearchTree<KeyType, ItemType>::BinarySearchTree(const BinarySearchTree<KeyType,ItemType>& tree) {
	rootPtr = copyTree(tree.rootPtr);
} //end copy constructor

template<typename KeyType, typename ItemType>
BinaryNode<ItemType>* BinarySearchTree<KeyType, ItemType>::copyTree(const BinaryNode<ItemType>* treePtr) {
	BinaryNode<ItemType>* newTreePtr = nullptr;

	//copy tree nodes during a preorder traversal
	if (treePtr != nullptr) {
		//CopyNode
		newTreePtr = new BinaryNode<ItemType>(treePtr->getItem());
		newTreePtr->setLeftChildPtr(copyTree(treePtr->getLeftChildPtr()));
		newTreePtr->setRightChildPtr(copyTree(treePtr->getRightChildPtr()));
	}
	//else
		//the tree is empty, there is nothing to copy, so the newTreePtr will be a nullptr.
	return newTreePtr;
} //end copyTree

template<typename KeyType, typename ItemType>
BinarySearchTree<KeyType, ItemType>::~BinarySearchTree()
{
	destroyTree(rootPtr);
}  // end destructor

template<typename KeyType, typename ItemType>
void BinarySearchTree<KeyType, ItemType>::destroyTree(const BinaryNode<ItemType>* subTreePtr) {
	BinaryNode<ItemType>* newTreePtr = nullptr;

	//copy tree nodes during a postorder traversal
	if (subTreePtr != nullptr) {
		//Destroy node
		destroyTree(subTreePtr->getLeftChildPtr());
		destroyTree(subTreePtr->getRightChildPtr());
		delete subTreePtr;
	}
	//else
		//the tree is empty, there is nothing to destroy
} //end destroyTree

template<typename KeyType, typename ItemType>
bool BinarySearchTree<KeyType, ItemType>::isEmpty() const {
	return (rootPtr == nullptr);

}  // end isEmpty

template<typename KeyType, typename ItemType>
int BinarySearchTree<KeyType, ItemType>::getHeight() const {
	return superGetHeight(rootPtr);
} // end getHeight

template<typename KeyType, typename ItemType>
int BinarySearchTree<KeyType, ItemType>::superGetHeight(BinaryNode<ItemType>* leaf) const {
	
	if (leaf == nullptr)
		return 0; //there are no nodes in the tree, the height is 0
	else
		return 1 + max(superGetHeight(leaf->getLeftChildPtr()), superGetHeight(leaf->getRightChildPtr())); //the height will be at least 1, we have to add the ight of the bigger subtree
} //end superGetHeight

template<typename KeyType, typename ItemType>
int BinarySearchTree<KeyType, ItemType>::getNumberOfNodes() const {
	return nodeCount;
} //end getNumberOfNodes

template<typename KeyType, typename ItemType>
void BinarySearchTree<KeyType, ItemType>::add(const ItemType& newEntry)
{
//lets see how is the root pointer
	/*cout << "rootptr item: " << rootPtr->getItem() << endl;
	cout << "left child: " << (rootPtr->getLeftChildPtr())->getItem() << endl;
	cout << "right child: " << (rootPtr->getRightChildPtr())->getItem() << endl;*/

	if (nodeCount == 0){
		//this means there are no nodes in the tree
		//the root pointer is currently a nullptr
		BinaryNode<ItemType>* tmp = new BinaryNode<ItemType>(newEntry);
		rootPtr = tmp;
		nodeCount = 1;
	} else {
		superAdd(newEntry, rootPtr);
	}
}  // end add

template<typename KeyType, typename ItemType>
void BinarySearchTree<KeyType, ItemType>::superAdd(const ItemType& newEntry, BinaryNode<ItemType>* leaf)
{
	if (newEntry < leaf->getItem()){
		//go to the left
		BinaryNode<ItemType>* leftPtr = leaf->getLeftChildPtr();
		//get pointer of the left child
		if (leftPtr != nullptr)
		//there is a left child
		//then the program should keep looking starting from that left child
			superAdd(newEntry, leftPtr);
		else{
		//if there is no left child, then the new entry must go there
			BinaryNode<ItemType>* newNodePtr = new BinaryNode<ItemType>(newEntry);
			leaf->setLeftChildPtr(newNodePtr);
			nodeCount++;
		}
	} else if (newEntry >= leaf->getItem()){
		//go to the right
		BinaryNode<ItemType>* rightPtr = leaf->getRightChildPtr();
		//get pointer of the right child
		if (rightPtr != nullptr)
		//there is a right child
		//then the program should keep looking starting from that right child
			superAdd(newEntry, rightPtr);
		else{
		//if there is no right child, then the new entry must go there
			BinaryNode<ItemType>* newNodePtr = new BinaryNode<ItemType>(newEntry);
			leaf->setRightChildPtr(newNodePtr);
			nodeCount++;
		}
	}
}  // end superAdd

template<typename KeyType, typename ItemType>
void BinarySearchTree<KeyType, ItemType>::remove(const KeyType& aKey) throw(NotFoundException)
{
	try {
	//calling helper method
	rootPtr = removeValue(rootPtr, aKey);
	} catch (NotFoundException e) {
		cerr << "The item was not found. " << e.what() << endl;
	}
}  // end remove

template<typename KeyType, typename ItemType>
BinaryNode<ItemType>* BinarySearchTree<KeyType, ItemType>::removeValue(BinaryNode<ItemType>* subTree, const KeyType& targetKey)
{
	if (subTree == nullptr){
		//the item is never reached, a nullptr appears
		string message = "The key is not in the tree.";
		throw NotFoundException(message);

	} else if (subTree->getItem() == targetKey){
		//the target is in the current node
		subTree = removeNode(subTree); //remove the item
		nodeCount--; //as the item is removed, the node count should decrease
		return subTree;
	} else if (subTree->getItem() > targetKey) {
		//the current node is greater than the target
		//need to search the left subtree
		BinaryNode<ItemType>* temp = removeValue(subTree->getLeftChildPtr(), targetKey);
		subTree->setLeftChildPtr(temp);
		return subTree;

	} else {
		//the current node's item is less than the target
		//need to search the right subtree
		BinaryNode<ItemType>* temp = removeValue(subTree->getRightChildPtr(), targetKey);
		subTree->setRightChildPtr(temp);
		return subTree;
	}

}  // end removeValue

template<typename KeyType, typename ItemType>
BinaryNode<ItemType>* BinarySearchTree<KeyType, ItemType>::removeNode(BinaryNode<ItemType>* targetNode)
{
	bool noLeftChild = (targetNode->getLeftChildPtr() == nullptr); //true if there is no left child
	bool noRightChild = (targetNode->getRightChildPtr() == nullptr); //true if there is no right child

	if (noLeftChild && noRightChild){
		//the target node has no children, it is a leaf
		//simply remove the target node
		delete targetNode;
		targetNode = nullptr;
		return targetNode;
		
	} else if ((noRightChild && !noLeftChild)||(noLeftChild && !noRightChild)){

		BinaryNode<ItemType>* connectionNode;

		if (!noLeftChild)
			//the node has only one child: the left child
			connectionNode = targetNode->getLeftChildPtr();
		else
			//the node has only one child: the right child
			connectionNode = targetNode->getRightChildPtr();

		delete targetNode;
		targetNode = nullptr;
		return connectionNode;

	} else {//the target node has two children
		//Find S = in order sucessor
		//Copy item from the node S into target node
		//remove S from the tree by using the previous technique for a leaf or a node wiht one child
		ItemType newNodeValue;
		BinaryNode<ItemType>* tempPtr = removeLeftmostNode(targetNode->getRightChildPtr(), newNodeValue);
		targetNode->setRightChildPtr(tempPtr);
		targetNode->setItem(newNodeValue); //put replacement value
		return targetNode;
	}

}  // end removeNode


template<typename KeyType, typename ItemType>
BinaryNode<ItemType>* BinarySearchTree<KeyType, ItemType>::removeLeftmostNode(BinaryNode<ItemType>* node, ItemType& inorderSuccessor)
{
	if (node->getLeftChildPtr() == nullptr){
		//this is the leftmost node as it has no left child
		inorderSuccessor = node->getItem(); //sets the value of inorderSuccesor, which will be replace on the target node
		return removeNode(node); //this will remove the node
			//as it has either 1 child or no children, it is one of the basic cases.
		
	} else {
		//we need to find the left child pointer again
		node->setLeftChildPtr(removeLeftmostNode(node->getLeftChildPtr(), inorderSuccessor));
		return node;
	}
} // end removeLeftMostNode

template<typename KeyType, typename ItemType>
ItemType BinarySearchTree<KeyType, ItemType>::getEntry(const KeyType& aKey) const throw(NotFoundException)
{
	BinaryNode<ItemType>* result = search(aKey, rootPtr);

	if (result == nullptr){
		//tree doesnt contain the item
		stringstream some;
		some << "The key " << aKey << " is not in the tree.";
		throw NotFoundException(some.str());
	} else
		//tree contains the item
		return result->getItem();

}  // end getEntry

template<typename KeyType, typename ItemType>
bool BinarySearchTree<KeyType, ItemType>::contains(const KeyType& aKey) const
{
	BinaryNode<ItemType>* result = search(aKey, rootPtr);

	if (result == nullptr)
		//tree doesnt contain the item
		return false;
	else
		//tree contains the item
		return true;

}  // end contains

template<typename KeyType, typename ItemType>
BinaryNode<ItemType>* BinarySearchTree<KeyType, ItemType>::search(const KeyType& aKey, BinaryNode<ItemType>* leaf) const throw(NotFoundException)
{
	if (leaf == nullptr)
		return nullptr;
		//the item should be here or a child from current node
		//but the node is a nullpointer, so the item doesnt belong to the tree
	if (leaf->getItem() == aKey)
		//the item exists in the tree and it is in the node we are currently at
		return leaf;
	else if (leaf->getItem() > aKey){
		BinaryNode<ItemType>* leftPtr = leaf->getLeftChildPtr();
		//get pointer of the left child
		//the item should be the leftchild or in its subtree
		return search(aKey, leftPtr);
	} else if (leaf->getItem() < aKey){
		BinaryNode<ItemType>* rightPtr = leaf->getRightChildPtr();
		//get pointer of the right child
		//the item should be the rightchild or in its subtree
		return search(aKey, rightPtr);
	}

}  // end search

template<typename KeyType, typename ItemType>
void BinarySearchTree<KeyType, ItemType>::preorderTraverse(void visit(ItemType&)) const
{
 	superPreorderTraverse(visit, rootPtr);
}  // end preorderTraverse

template<typename KeyType, typename ItemType>
void BinarySearchTree<KeyType, ItemType>::superPreorderTraverse(void visit(ItemType&), BinaryNode<ItemType>* leaf) const
{
 	if (leaf != nullptr){
		//visit current node
		ItemType currentItem = leaf->getItem();
		visit(currentItem);
		//go Left
		BinaryNode<ItemType>* leftPtr = leaf->getLeftChildPtr();
		superPreorderTraverse(visit, leftPtr);
		//go Right
		BinaryNode<ItemType>* rightPtr = leaf->getRightChildPtr();
		superPreorderTraverse(visit, rightPtr);
	}
}  // end superPreorderTraverse

template<typename KeyType, typename ItemType>
void BinarySearchTree<KeyType, ItemType>::inorderTraverse(void visit(ItemType&)) const
{
 	superInorderTraverse(visit, rootPtr);
}  // end inorderTraverse

//recordar que cuando tenga mi manager class y use el inorder traverse, debo definir el metodo que va a tomar el lugar de visit

template<typename KeyType, typename ItemType>
void BinarySearchTree<KeyType, ItemType>::superInorderTraverse(void visit(ItemType&), BinaryNode<ItemType>* leaf) const
{
 	if (leaf != nullptr){
		//go Left
		BinaryNode<ItemType>* leftPtr = leaf->getLeftChildPtr();
		superInorderTraverse(visit, leftPtr);
		//visit current node
		ItemType currentItem = leaf->getItem();
		visit(currentItem);
		//go Right
		BinaryNode<ItemType>* rightPtr = leaf->getRightChildPtr();
		superInorderTraverse(visit, rightPtr);
	}
}  // end superInorderTraverse

template<typename KeyType, typename ItemType>
void BinarySearchTree<KeyType, ItemType>::postorderTraverse(void visit(ItemType&)) const
{
 	superPostorderTraverse(visit, rootPtr);
}  // end postorderTraverse

template<typename KeyType, typename ItemType>
void BinarySearchTree<KeyType, ItemType>::superPostorderTraverse(void visit(ItemType&), BinaryNode<ItemType>* leaf) const
{
 	if (leaf != nullptr){
		//go Left
		BinaryNode<ItemType>* leftPtr = leaf->getLeftChildPtr();
		superPostorderTraverse(visit, leftPtr);
		//go Right
		BinaryNode<ItemType>* rightPtr = leaf->getRightChildPtr();
		superPostorderTraverse(visit, rightPtr);
		//visit current node
		ItemType currentItem = leaf->getItem();
		visit(currentItem);
	}
}  // end superPostorderTraverse


//  End of implementation file.
